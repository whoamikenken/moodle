{"version":3,"file":"convert_to_mp3.min.js","sources":["../src/convert_to_mp3.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Convert audio to MP3.\n *\n * @module     tiny_recordrtc/convert_to_mp3\n * @copyright  Meirza <meirza.arson@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport lamejs from './lame.all';\n\n/**\n * Extract Pulse Code Modulation (PCM) data from an AudioBuffer to get raw channel data.\n *\n * @param {AudioBuffer} audioBuffer The AudioBuffer containing the audio data.\n * @returns {Array<Int16Array>} The PCM data for each channel.\n */\nconst extractPCM = (audioBuffer) => {\n    const channelData = [];\n    const numberOfChannels = audioBuffer.numberOfChannels;\n    const audioBufferLength = audioBuffer.length;\n\n    for (let channel = 0; channel < numberOfChannels; channel++) {\n        const rawChannelData = audioBuffer.getChannelData(channel);\n        channelData[channel] = new Int16Array(audioBufferLength);\n        // Convert floating-point audio samples into 16-bit signed integer values.\n        for (let i = 0; i < audioBufferLength; i++) {\n            channelData[channel][i] = rawChannelData[i] * 32768;\n        }\n    }\n\n    return channelData;\n};\n\n/**\n * Fetches and decodes the audio data from a given URL into an AudioBuffer.\n *\n * @param {string} sourceUrl - The URL of the source audio file.\n * @returns {Promise<AudioBuffer>} - A promise that resolves with the decoded AudioBuffer object.\n */\nconst getAudioBuffer = async(sourceUrl) => {\n    const response = await fetch(sourceUrl);\n    const arrayBuffer = await response.arrayBuffer();\n    const audioContext = new (\n        window.AudioContext // Default.\n        || window.webkitAudioContext // Safari and old versions of Chrome.\n    )();\n    return audioContext.decodeAudioData(arrayBuffer);\n};\n\n/**\n * Converts an AudioBuffer to MP3 format using lamejs.\n *\n * @param {Object} lamejs - The lamejs library object.\n * @param {number} channels - The number of audio channels (1 for mono, 2 for stereo).\n * @param {number} sampleRate - The sample rate of the audio (e.g., 44100 Hz).\n * @param {number} bitRate - The bitrate (in kbps) to encode the MP3.\n * @param {Int16Array} left - The PCM data for the left channel.\n * @param {Int16Array} [right=null] - The PCM data for the right channel (optional for stereo).\n * @returns {Blob} - A Blob containing the MP3 audio data.\n */\nconst convertAudioBuffer = (lamejs, channels, sampleRate, bitRate, left, right = null) => {\n    const mp3Data = [];\n    const mp3Encoder = new lamejs.Mp3Encoder(channels, sampleRate, bitRate);\n    // Each frame represents 1152 audio samples per channel (for both mono and stereo).\n    const sampleBlockSize = 1152;\n\n    // Ensure that the same encoding logic works for both mono and stereo audio by\n    // either passing both channels or just the left channel to the MP3 encoder.\n    for (let i = 0; i < left.length; i += sampleBlockSize) {\n        const leftChunk = left.subarray(i, i + sampleBlockSize);\n        const mp3Buf = right\n            ? mp3Encoder.encodeBuffer(leftChunk, right.subarray(i, i + sampleBlockSize)) // Stereo.\n            : mp3Encoder.encodeBuffer(leftChunk); // Mono.\n\n        if (mp3Buf.length) {\n            mp3Data.push(mp3Buf);\n        }\n    }\n\n    // Preventing loss of the last few samples of audio.\n    const mp3Buf = mp3Encoder.flush();\n    if (mp3Buf.length) {\n        mp3Data.push(new Int8Array(mp3Buf));\n    }\n\n    return new Blob(mp3Data, {type: 'audio/mp3'});\n};\n\n/**\n * Main function to handle the entire process of converting an audio file to MP3 format.\n *\n * @param {string} sourceUrl - The URL of the source audio file to be converted.\n * @param {number} [bitRate=128] - The bitrate (in kbps) for the MP3 conversion. Default is 128 kbps.\n * @returns {Promise<Blob>} - A promise that resolves with the MP3 file as a Blob.\n *\n * @throws {Error} If the Lamejs module or audio buffer fails to load.\n *\n * @example\n * const mp3Data = await convertMp3('audio-source.wav', 192);\n * window.console.log(mp3Data); // Logs the ArrayBuffer with MP3 data.\n */\nexport const convertMp3 = async(sourceUrl, bitRate = 128) => {\n    const audioBuffer = await getAudioBuffer(sourceUrl);\n    const [left, right] = extractPCM(audioBuffer);\n    return convertAudioBuffer(lamejs, audioBuffer.numberOfChannels, audioBuffer.sampleRate, bitRate, left, right);\n};\n"],"names":["extractPCM","audioBuffer","channelData","numberOfChannels","audioBufferLength","length","channel","rawChannelData","getChannelData","Int16Array","i","getAudioBuffer","async","response","fetch","sourceUrl","arrayBuffer","window","AudioContext","webkitAudioContext","decodeAudioData","convertAudioBuffer","lamejs","channels","sampleRate","bitRate","left","right","mp3Data","mp3Encoder","Mp3Encoder","sampleBlockSize","leftChunk","subarray","mp3Buf","encodeBuffer","push","flush","Int8Array","Blob","type"],"mappings":";;;;;;;kJA+BMA,WAAcC,oBACVC,YAAc,GACdC,iBAAmBF,YAAYE,iBAC/BC,kBAAoBH,YAAYI,WAEjC,IAAIC,QAAU,EAAGA,QAAUH,iBAAkBG,UAAW,OACnDC,eAAiBN,YAAYO,eAAeF,SAClDJ,YAAYI,SAAW,IAAIG,WAAWL,uBAEjC,IAAIM,EAAI,EAAGA,EAAIN,kBAAmBM,IACnCR,YAAYI,SAASI,GAAyB,MAApBH,eAAeG,UAI1CR,aASLS,eAAiBC,MAAAA,kBACbC,eAAiBC,MAAMC,WACvBC,kBAAoBH,SAASG,qBACd,IACjBC,OAAOC,cACJD,OAAOE,qBAEMC,gBAAgBJ,cAclCK,mBAAqB,SAACC,OAAQC,SAAUC,WAAYC,QAASC,UAAMC,6DAAQ,WACvEC,QAAU,GACVC,WAAa,IAAIP,OAAOQ,WAAWP,SAAUC,WAAYC,SAEzDM,gBAAkB,SAInB,IAAIrB,EAAI,EAAGA,EAAIgB,KAAKrB,OAAQK,GAAKqB,gBAAiB,OAC7CC,UAAYN,KAAKO,SAASvB,EAAGA,EAAIqB,iBACjCG,OAASP,MACTE,WAAWM,aAAaH,UAAWL,MAAMM,SAASvB,EAAGA,EAAIqB,kBACzDF,WAAWM,aAAaH,WAE1BE,OAAO7B,QACPuB,QAAQQ,KAAKF,cAKfA,OAASL,WAAWQ,eACtBH,OAAO7B,QACPuB,QAAQQ,KAAK,IAAIE,UAAUJ,SAGxB,IAAIK,KAAKX,QAAS,CAACY,KAAM,mCAgBV5B,eAAMG,eAAWU,+DAAU,UAC3CxB,kBAAoBU,eAAeI,YAClCW,KAAMC,OAAS3B,WAAWC,oBAC1BoB,mBAAmBC,cAAQrB,YAAYE,iBAAkBF,YAAYuB,WAAYC,QAASC,KAAMC"}