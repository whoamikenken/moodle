{"version":3,"file":"embed.min.js","sources":["../src/embed.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Tiny Media plugin Embed class for Moodle.\n *\n * @module      tiny_media/embed\n * @copyright   2022 Huong Nguyen <huongnv13@gmail.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport EmbedModal from './embedmodal';\nimport {getEmbedPermissions} from './options';\nimport {getFilePicker, getContextId} from 'editor_tiny/options';\nimport {EmbedHandler} from './embed/embedhandler';\nimport {insertMediaTemplateContext, getSelectedMediaElement} from './embed/embedhelpers';\nimport {EmbedInsert} from './embed/embedinsert';\nimport {startMediaLoading} from './helpers';\nimport Selectors from \"./selectors\";\n\nexport default class MediaEmbed {\n    editor = null;\n    canShowFilePicker = false;\n    canShowFilePickerTrack = false;\n    canShowDropZone = false;\n\n    constructor(editor) {\n        const permissions = getEmbedPermissions(editor);\n        const options = getFilePicker(editor, 'media');\n\n        // Indicates whether the file picker can be shown.\n        this.canShowFilePicker = permissions.filepicker\n            && (typeof options !== 'undefined')\n            && Object.keys(options.repositories).length > 0;\n        this.canShowFilePickerTrack = permissions.filepicker && (typeof getFilePicker(editor, 'subtitle') !== 'undefined');\n        this.canShowDropZone = Object.values(options.repositories).some(repository => repository.type === 'upload');\n        this.editor = editor;\n        this.acceptedMediaTypes = options.accepted_types;\n        this.contextId = getContextId(editor);\n\n        // Image options.\n        const imageOptions = getFilePicker(editor, 'image');\n        this.acceptedImageTypes = imageOptions.accepted_types;\n        this.canShowImageFilePicker = permissions.filepicker\n            && (typeof imageOptions !== 'undefined')\n            && Object.keys(imageOptions.repositories).length > 0;\n    }\n\n    /**\n     * Displays media modal accordingly.\n     */\n    displayDialogue = async() => {\n        const [mediaType, selectedMedia] = getSelectedMediaElement(this.editor);\n        this.mediaType = mediaType;\n        this.selectedMedia = selectedMedia;\n\n        if (this.selectedMedia) {\n            // Preview the selected media.\n            this.isUpdating = true;\n            this.loadSelectedMedia();\n        } else {\n            // Create media modal.\n            await this.createMediaModal();\n            // Load insert media modal.\n            await this.loadInsertMediaModal();\n        }\n    };\n\n    /**\n     * Load insert media modal.\n     */\n    loadInsertMediaModal = async() => {\n        const embedHandler = new EmbedHandler(this);\n        embedHandler.loadTemplatePromise(insertMediaTemplateContext(this));\n        await embedHandler.registerEventListeners();\n    };\n\n    /**\n     * Create media modal.\n     */\n    createMediaModal = async() => {\n        this.currentModal = await EmbedModal.create({\n            large: true,\n            templateContext: {elementid: this.editor.getElement().id},\n        });\n        this.modalRoot = this.currentModal.getRoot();\n        this.root = this.modalRoot[0];\n    };\n\n    /**\n     * Load media preview based on the selected media.\n     */\n    loadSelectedMedia = async() => {\n        let mediaSource = null;\n        if (['video', 'audio'].includes(this.mediaType)) {\n            mediaSource = this.selectedMedia.querySelector('source').src;\n            // If the selected media has more than one sources, it has main source and alternative sources.\n            const sources = this.selectedMedia.querySelectorAll('source');\n            if (sources.length > 1) {\n                let alternativeSources = [];\n                Object.keys(sources).forEach(function(source) {\n                    alternativeSources.push(sources[source].src);\n                });\n                this.alternativeSources = alternativeSources; // Used to later check if the embedded media has alternative sources.\n            }\n        } else if (this.selectedMedia.classList.contains(Selectors.EMBED.externalMediaProvider)) {\n            mediaSource = this.selectedMedia.href;\n            this.mediaType = 'link';\n        }\n\n        // Load media preview.\n        if (this.mediaType) {\n            // Create media modal.\n            await this.createMediaModal();\n            // Start the spinner.\n            startMediaLoading(this.root, Selectors.EMBED.type);\n\n            const embedInsert = new EmbedInsert(this);\n            embedInsert.init();\n            embedInsert.loadMediaPreview(mediaSource);\n            await (new EmbedHandler(this)).registerEventListeners();\n        } else {\n            // Create media modal.\n            await this.createMediaModal();\n            // Load insert media modal.\n            this.loadInsertMediaModal();\n        }\n    };\n}\n"],"names":["constructor","editor","async","mediaType","selectedMedia","this","isUpdating","loadSelectedMedia","createMediaModal","loadInsertMediaModal","embedHandler","EmbedHandler","loadTemplatePromise","registerEventListeners","currentModal","EmbedModal","create","large","templateContext","elementid","getElement","id","modalRoot","getRoot","root","mediaSource","includes","querySelector","src","sources","querySelectorAll","length","alternativeSources","Object","keys","forEach","source","push","classList","contains","Selectors","EMBED","externalMediaProvider","href","type","embedInsert","EmbedInsert","init","loadMediaPreview","permissions","options","canShowFilePicker","filepicker","repositories","canShowFilePickerTrack","canShowDropZone","values","some","repository","acceptedMediaTypes","accepted_types","contextId","imageOptions","acceptedImageTypes","canShowImageFilePicker"],"mappings":"uuBAsCIA,YAAYC,sCALH,gDACW,kDACK,2CACP,2CA2BAC,gBACPC,UAAWC,gBAAiB,yCAAwBC,KAAKJ,aAC3DE,UAAYA,eACZC,cAAgBA,cAEjBC,KAAKD,oBAEAE,YAAa,OACbC,4BAGCF,KAAKG,yBAELH,KAAKI,wEAOIP,gBACbQ,aAAe,IAAIC,2BAAaN,MACtCK,aAAaE,qBAAoB,4CAA2BP,aACtDK,aAAaG,qEAMJX,eACVY,mBAAqBC,oBAAWC,OAAO,CACxCC,OAAO,EACPC,gBAAiB,CAACC,UAAWd,KAAKJ,OAAOmB,aAAaC,WAErDC,UAAYjB,KAAKS,aAAaS,eAC9BC,KAAOnB,KAAKiB,UAAU,gDAMXpB,cACZuB,YAAc,QACd,CAAC,QAAS,SAASC,SAASrB,KAAKF,WAAY,CAC7CsB,YAAcpB,KAAKD,cAAcuB,cAAc,UAAUC,UAEnDC,QAAUxB,KAAKD,cAAc0B,iBAAiB,aAChDD,QAAQE,OAAS,EAAG,KAChBC,mBAAqB,GACzBC,OAAOC,KAAKL,SAASM,SAAQ,SAASC,QAClCJ,mBAAmBK,KAAKR,QAAQO,QAAQR,aAEvCI,mBAAqBA,yBAEvB3B,KAAKD,cAAckC,UAAUC,SAASC,mBAAUC,MAAMC,yBAC7DjB,YAAcpB,KAAKD,cAAcuC,UAC5BxC,UAAY,WAIjBE,KAAKF,UAAW,OAEVE,KAAKG,kDAEOH,KAAKmB,KAAMgB,mBAAUC,MAAMG,YAEvCC,YAAc,IAAIC,yBAAYzC,MACpCwC,YAAYE,OACZF,YAAYG,iBAAiBvB,mBACtB,IAAId,2BAAaN,MAAOQ,oCAGzBR,KAAKG,wBAENC,gCAlGHwC,aAAc,gCAAoBhD,QAClCiD,SAAU,2BAAcjD,OAAQ,cAGjCkD,kBAAoBF,YAAYG,iBACV,IAAZF,SACRjB,OAAOC,KAAKgB,QAAQG,cAActB,OAAS,OAC7CuB,uBAAyBL,YAAYG,iBAA4D,KAAtC,2BAAcnD,OAAQ,iBACjFsD,gBAAkBtB,OAAOuB,OAAON,QAAQG,cAAcI,MAAKC,YAAkC,WAApBA,WAAWd,YACpF3C,OAASA,YACT0D,mBAAqBT,QAAQU,oBAC7BC,WAAY,0BAAa5D,cAGxB6D,cAAe,2BAAc7D,OAAQ,cACtC8D,mBAAqBD,aAAaF,oBAClCI,uBAAyBf,YAAYG,iBACV,IAAjBU,cACR7B,OAAOC,KAAK4B,aAAaT,cAActB,OAAS"}