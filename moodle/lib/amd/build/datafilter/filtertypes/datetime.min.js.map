{"version":3,"file":"datetime.min.js","sources":["../../../src/datafilter/filtertypes/datetime.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Base filter for a date/time selector\n *\n * @module     core/datafilter/filtertypes/datetime\n * @author     Mark Johnson <mark.johnson@catalyst-eu.net>\n * @copyright  2024 Catalyst IT Europe Ltd\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Filter from 'core/datafilter/filtertype';\nimport Selectors from 'core/datafilter/selectors';\nimport Templates from 'core/templates';\nimport Notification from 'core/notification';\nimport {get_strings as getStrings} from 'core/str';\n\nconst MODES = {\n    before: 'before',\n    after: 'after',\n    between: 'between',\n};\n\nexport default class extends Filter {\n\n    SELECTORS = {\n        afterwrapper: `.${this.filterType}-afterwrapper`,\n        beforewrapper: `.${this.filterType}-beforewrapper`,\n        betweenwrapper: `.${this.filterType}-betweenwrapper`,\n        mode: `[data-filterfield=${this.filterType}-mode]`,\n    };\n\n    mode = null;\n\n    constructor(filterType, rootNode, initialValues, filterOptions = {mode: MODES.before}) {\n        super(filterType, rootNode, initialValues);\n        this.addModeSelector(filterOptions.mode);\n    }\n\n    /**\n     * Get the context object to be sent through to the mustache template.\n     * This can be overridden by any filters which inherit from datetime to add/exclude data.\n     *\n     * @param {array} initialValues\n     * @returns {Promise<{filtertype: *, afterlabel: *, beforelabel: *, required, aftervalue: *, beforevalue: *}>}\n     */\n    async getContext(initialValues) {\n        const sourceDataNode = this.getSourceDataForFilter();\n        const defaultBefore = sourceDataNode.getElementsByTagName('option')[0].value;\n        const defaultAfter = sourceDataNode.getElementsByTagName('option')[1].value;\n        const title = sourceDataNode.getAttribute('data-field-title');\n        const labels = await getStrings([\n            {\n                key: 'datetimefilterafter',\n                component: 'core',\n                param: {title},\n            },\n            {\n                key: 'datetimefilterbefore',\n                component: 'core',\n                param: {title},\n            },\n        ]);\n        return {\n            filtertype: this.filterType,\n            afterlabel: labels[0],\n            beforelabel: labels[1],\n            required: sourceDataNode.dataset.required,\n            aftervalue: initialValues[0] ?? defaultAfter,\n            beforevalue: initialValues[1] ?? defaultBefore,\n        };\n    }\n\n    async addValueSelector(initialValues = []) {\n        // We specify a specific filterset in case there are multiple filtering condition - avoiding glitches.\n        const specificFilterSet = this.rootNode.querySelector(Selectors.filter.byName(this.filterType));\n        const context = await this.getContext(initialValues);\n        const datetimeUi = await Templates.renderForPromise('core/datafilter/filtertypes/datetime_selector', context);\n        return Templates.replaceNodeContents(\n            specificFilterSet.querySelector(Selectors.filter.regions.values),\n            datetimeUi.html,\n            datetimeUi.js\n        );\n    }\n    async addModeSelector(mode) {\n        const modeStrings = await getStrings([\n            {key: 'selectdates'},\n            {key: 'filterdatebefore', component: 'reportbuilder'},\n            {key: 'filterdateafter', component: 'reportbuilder'},\n            {key: 'between'}\n        ]);\n        const context = {\n            label: modeStrings[0],\n            filtertype: this.filterType,\n            modeoptions: [\n                {\n                    value: MODES.before,\n                    label: modeStrings[1],\n                    selected: mode === MODES.before ? 'selected' : '',\n                },\n                {\n                    value: MODES.after,\n                    label: modeStrings[2],\n                    selected: mode === MODES.after ? 'selected' : '',\n                },\n                {\n                    value: MODES.between,\n                    label: modeStrings[3],\n                    selected: mode === MODES.between ? 'selected' : '',\n                },\n            ],\n        };\n        const modeUi = await Templates.renderForPromise('core/datafilter/filtertypes/datetime_mode', context);\n        const filterValueNode = this.getFilterValueNode();\n        filterValueNode.insertAdjacentHTML('beforebegin', modeUi.html);\n        const modeSelect = this.filterRoot.querySelector(this.SELECTORS.mode);\n        modeSelect.addEventListener('change', this.updateFieldVisibility.bind(this));\n        modeSelect.dispatchEvent(new Event('change')); // Update field visibility based on initial mode.\n    }\n\n    updateFieldVisibility(event) {\n        const filterValueNode = this.getFilterValueNode();\n        const afterWrapper = filterValueNode.querySelector(this.SELECTORS.afterwrapper);\n        const beforeWrapper = filterValueNode.querySelector(this.SELECTORS.beforewrapper);\n        const betweenWrapper = filterValueNode.querySelector(this.SELECTORS.betweenwrapper);\n        const value = event.target.value;\n        if (value === MODES.between) {\n            betweenWrapper.classList.remove('d-none');\n        } else {\n            betweenWrapper.classList.add('d-none');\n        }\n        if (value === MODES.after || value === MODES.between) {\n            afterWrapper.classList.remove('d-none');\n        } else {\n            afterWrapper.classList.add('d-none');\n        }\n        if (value === MODES.before || value === MODES.between) {\n            beforeWrapper.classList.remove('d-none');\n        } else {\n            beforeWrapper.classList.add('d-none');\n        }\n    }\n\n    get values() {\n        return [\n            this.filterRoot.querySelector(`[data-filterfield=\"${this.name}1\"]`).value,\n            this.filterRoot.querySelector(`[data-filterfield=\"${this.name}2\"]`).value,\n        ];\n    }\n\n    get filterOptions() {\n        return [\n            {name: 'mode', value: this.filterRoot.querySelector(this.SELECTORS.mode).value}\n        ];\n    }\n\n    get filterValue() {\n        return {\n            name: this.name,\n            jointype: this.jointype,\n            values: this.values,\n            filteroptions: this.filterOptions,\n        };\n    }\n\n    validate() {\n        const mode = document.querySelector(this.SELECTORS.mode).value;\n        const before = document.querySelector(this.SELECTORS.beforewrapper + ' input');\n        const after = document.querySelector(this.SELECTORS.afterwrapper + ' input');\n        after.setCustomValidity('');\n        if (mode === MODES.between) {\n            if (after.value >= before.value) {\n                getStrings([\n                    {\n                        key: 'invaliddatetimebetween',\n                        component: 'error',\n                        param: {\n                            before: before.value,\n                            after: after.value,\n                        },\n                    },\n                ]).then((strings) => {\n                    after.setCustomValidity(strings[0]);\n                    after.reportValidity();\n                    return strings;\n                }).catch(Notification.exception);\n                return false;\n            }\n        }\n\n        return true;\n    }\n}"],"names":["MODES","Filter","constructor","filterType","rootNode","initialValues","filterOptions","mode","afterwrapper","this","beforewrapper","betweenwrapper","addModeSelector","sourceDataNode","getSourceDataForFilter","defaultBefore","getElementsByTagName","value","defaultAfter","title","getAttribute","labels","key","component","param","filtertype","afterlabel","beforelabel","required","dataset","aftervalue","beforevalue","specificFilterSet","querySelector","Selectors","filter","byName","context","getContext","datetimeUi","Templates","renderForPromise","replaceNodeContents","regions","values","html","js","modeStrings","label","modeoptions","selected","modeUi","getFilterValueNode","insertAdjacentHTML","modeSelect","filterRoot","SELECTORS","addEventListener","updateFieldVisibility","bind","dispatchEvent","Event","event","filterValueNode","afterWrapper","beforeWrapper","betweenWrapper","target","classList","remove","add","name","filterValue","jointype","filteroptions","validate","document","before","after","setCustomValidity","then","strings","reportValidity","catch","Notification","exception"],"mappings":"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"}